// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.26.0
// source: iamanager/v5/iamanager.proto

package iamanager

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IAMPublicServiceClient is the client API for IAMPublicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMPublicServiceClient interface {
	GetNodeInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NodeInfo, error)
	GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*CertInfo, error)
	SubscribeCertChanged(ctx context.Context, in *SubscribeCertChangedRequest, opts ...grpc.CallOption) (IAMPublicService_SubscribeCertChangedClient, error)
}

type iAMPublicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMPublicServiceClient(cc grpc.ClientConnInterface) IAMPublicServiceClient {
	return &iAMPublicServiceClient{cc}
}

func (c *iAMPublicServiceClient) GetNodeInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NodeInfo, error) {
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPublicService/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMPublicServiceClient) GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*CertInfo, error) {
	out := new(CertInfo)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPublicService/GetCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMPublicServiceClient) SubscribeCertChanged(ctx context.Context, in *SubscribeCertChangedRequest, opts ...grpc.CallOption) (IAMPublicService_SubscribeCertChangedClient, error) {
	stream, err := c.cc.NewStream(ctx, &IAMPublicService_ServiceDesc.Streams[0], "/iamanager.v5.IAMPublicService/SubscribeCertChanged", opts...)
	if err != nil {
		return nil, err
	}
	x := &iAMPublicServiceSubscribeCertChangedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IAMPublicService_SubscribeCertChangedClient interface {
	Recv() (*CertInfo, error)
	grpc.ClientStream
}

type iAMPublicServiceSubscribeCertChangedClient struct {
	grpc.ClientStream
}

func (x *iAMPublicServiceSubscribeCertChangedClient) Recv() (*CertInfo, error) {
	m := new(CertInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IAMPublicServiceServer is the server API for IAMPublicService service.
// All implementations must embed UnimplementedIAMPublicServiceServer
// for forward compatibility
type IAMPublicServiceServer interface {
	GetNodeInfo(context.Context, *emptypb.Empty) (*NodeInfo, error)
	GetCert(context.Context, *GetCertRequest) (*CertInfo, error)
	SubscribeCertChanged(*SubscribeCertChangedRequest, IAMPublicService_SubscribeCertChangedServer) error
	mustEmbedUnimplementedIAMPublicServiceServer()
}

// UnimplementedIAMPublicServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMPublicServiceServer struct {
}

func (UnimplementedIAMPublicServiceServer) GetNodeInfo(context.Context, *emptypb.Empty) (*NodeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedIAMPublicServiceServer) GetCert(context.Context, *GetCertRequest) (*CertInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCert not implemented")
}
func (UnimplementedIAMPublicServiceServer) SubscribeCertChanged(*SubscribeCertChangedRequest, IAMPublicService_SubscribeCertChangedServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeCertChanged not implemented")
}
func (UnimplementedIAMPublicServiceServer) mustEmbedUnimplementedIAMPublicServiceServer() {}

// UnsafeIAMPublicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMPublicServiceServer will
// result in compilation errors.
type UnsafeIAMPublicServiceServer interface {
	mustEmbedUnimplementedIAMPublicServiceServer()
}

func RegisterIAMPublicServiceServer(s grpc.ServiceRegistrar, srv IAMPublicServiceServer) {
	s.RegisterService(&IAMPublicService_ServiceDesc, srv)
}

func _IAMPublicService_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPublicServiceServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPublicService/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPublicServiceServer).GetNodeInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMPublicService_GetCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPublicServiceServer).GetCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPublicService/GetCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPublicServiceServer).GetCert(ctx, req.(*GetCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMPublicService_SubscribeCertChanged_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeCertChangedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IAMPublicServiceServer).SubscribeCertChanged(m, &iAMPublicServiceSubscribeCertChangedServer{stream})
}

type IAMPublicService_SubscribeCertChangedServer interface {
	Send(*CertInfo) error
	grpc.ServerStream
}

type iAMPublicServiceSubscribeCertChangedServer struct {
	grpc.ServerStream
}

func (x *iAMPublicServiceSubscribeCertChangedServer) Send(m *CertInfo) error {
	return x.ServerStream.SendMsg(m)
}

// IAMPublicService_ServiceDesc is the grpc.ServiceDesc for IAMPublicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMPublicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMPublicService",
	HandlerType: (*IAMPublicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodeInfo",
			Handler:    _IAMPublicService_GetNodeInfo_Handler,
		},
		{
			MethodName: "GetCert",
			Handler:    _IAMPublicService_GetCert_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeCertChanged",
			Handler:       _IAMPublicService_SubscribeCertChanged_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "iamanager/v5/iamanager.proto",
}

// IAMPublicIdentityServiceClient is the client API for IAMPublicIdentityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMPublicIdentityServiceClient interface {
	GetSystemInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SystemInfo, error)
	GetSubjects(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Subjects, error)
	SubscribeSubjectsChanged(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (IAMPublicIdentityService_SubscribeSubjectsChangedClient, error)
}

type iAMPublicIdentityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMPublicIdentityServiceClient(cc grpc.ClientConnInterface) IAMPublicIdentityServiceClient {
	return &iAMPublicIdentityServiceClient{cc}
}

func (c *iAMPublicIdentityServiceClient) GetSystemInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SystemInfo, error) {
	out := new(SystemInfo)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPublicIdentityService/GetSystemInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMPublicIdentityServiceClient) GetSubjects(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Subjects, error) {
	out := new(Subjects)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPublicIdentityService/GetSubjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMPublicIdentityServiceClient) SubscribeSubjectsChanged(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (IAMPublicIdentityService_SubscribeSubjectsChangedClient, error) {
	stream, err := c.cc.NewStream(ctx, &IAMPublicIdentityService_ServiceDesc.Streams[0], "/iamanager.v5.IAMPublicIdentityService/SubscribeSubjectsChanged", opts...)
	if err != nil {
		return nil, err
	}
	x := &iAMPublicIdentityServiceSubscribeSubjectsChangedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IAMPublicIdentityService_SubscribeSubjectsChangedClient interface {
	Recv() (*Subjects, error)
	grpc.ClientStream
}

type iAMPublicIdentityServiceSubscribeSubjectsChangedClient struct {
	grpc.ClientStream
}

func (x *iAMPublicIdentityServiceSubscribeSubjectsChangedClient) Recv() (*Subjects, error) {
	m := new(Subjects)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IAMPublicIdentityServiceServer is the server API for IAMPublicIdentityService service.
// All implementations must embed UnimplementedIAMPublicIdentityServiceServer
// for forward compatibility
type IAMPublicIdentityServiceServer interface {
	GetSystemInfo(context.Context, *emptypb.Empty) (*SystemInfo, error)
	GetSubjects(context.Context, *emptypb.Empty) (*Subjects, error)
	SubscribeSubjectsChanged(*emptypb.Empty, IAMPublicIdentityService_SubscribeSubjectsChangedServer) error
	mustEmbedUnimplementedIAMPublicIdentityServiceServer()
}

// UnimplementedIAMPublicIdentityServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMPublicIdentityServiceServer struct {
}

func (UnimplementedIAMPublicIdentityServiceServer) GetSystemInfo(context.Context, *emptypb.Empty) (*SystemInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (UnimplementedIAMPublicIdentityServiceServer) GetSubjects(context.Context, *emptypb.Empty) (*Subjects, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubjects not implemented")
}
func (UnimplementedIAMPublicIdentityServiceServer) SubscribeSubjectsChanged(*emptypb.Empty, IAMPublicIdentityService_SubscribeSubjectsChangedServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeSubjectsChanged not implemented")
}
func (UnimplementedIAMPublicIdentityServiceServer) mustEmbedUnimplementedIAMPublicIdentityServiceServer() {
}

// UnsafeIAMPublicIdentityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMPublicIdentityServiceServer will
// result in compilation errors.
type UnsafeIAMPublicIdentityServiceServer interface {
	mustEmbedUnimplementedIAMPublicIdentityServiceServer()
}

func RegisterIAMPublicIdentityServiceServer(s grpc.ServiceRegistrar, srv IAMPublicIdentityServiceServer) {
	s.RegisterService(&IAMPublicIdentityService_ServiceDesc, srv)
}

func _IAMPublicIdentityService_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPublicIdentityServiceServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPublicIdentityService/GetSystemInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPublicIdentityServiceServer).GetSystemInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMPublicIdentityService_GetSubjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPublicIdentityServiceServer).GetSubjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPublicIdentityService/GetSubjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPublicIdentityServiceServer).GetSubjects(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMPublicIdentityService_SubscribeSubjectsChanged_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IAMPublicIdentityServiceServer).SubscribeSubjectsChanged(m, &iAMPublicIdentityServiceSubscribeSubjectsChangedServer{stream})
}

type IAMPublicIdentityService_SubscribeSubjectsChangedServer interface {
	Send(*Subjects) error
	grpc.ServerStream
}

type iAMPublicIdentityServiceSubscribeSubjectsChangedServer struct {
	grpc.ServerStream
}

func (x *iAMPublicIdentityServiceSubscribeSubjectsChangedServer) Send(m *Subjects) error {
	return x.ServerStream.SendMsg(m)
}

// IAMPublicIdentityService_ServiceDesc is the grpc.ServiceDesc for IAMPublicIdentityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMPublicIdentityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMPublicIdentityService",
	HandlerType: (*IAMPublicIdentityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSystemInfo",
			Handler:    _IAMPublicIdentityService_GetSystemInfo_Handler,
		},
		{
			MethodName: "GetSubjects",
			Handler:    _IAMPublicIdentityService_GetSubjects_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeSubjectsChanged",
			Handler:       _IAMPublicIdentityService_SubscribeSubjectsChanged_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "iamanager/v5/iamanager.proto",
}

// IAMPublicPermissionsServiceClient is the client API for IAMPublicPermissionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMPublicPermissionsServiceClient interface {
	GetPermissions(ctx context.Context, in *PermissionsRequest, opts ...grpc.CallOption) (*PermissionsResponse, error)
}

type iAMPublicPermissionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMPublicPermissionsServiceClient(cc grpc.ClientConnInterface) IAMPublicPermissionsServiceClient {
	return &iAMPublicPermissionsServiceClient{cc}
}

func (c *iAMPublicPermissionsServiceClient) GetPermissions(ctx context.Context, in *PermissionsRequest, opts ...grpc.CallOption) (*PermissionsResponse, error) {
	out := new(PermissionsResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPublicPermissionsService/GetPermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAMPublicPermissionsServiceServer is the server API for IAMPublicPermissionsService service.
// All implementations must embed UnimplementedIAMPublicPermissionsServiceServer
// for forward compatibility
type IAMPublicPermissionsServiceServer interface {
	GetPermissions(context.Context, *PermissionsRequest) (*PermissionsResponse, error)
	mustEmbedUnimplementedIAMPublicPermissionsServiceServer()
}

// UnimplementedIAMPublicPermissionsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMPublicPermissionsServiceServer struct {
}

func (UnimplementedIAMPublicPermissionsServiceServer) GetPermissions(context.Context, *PermissionsRequest) (*PermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermissions not implemented")
}
func (UnimplementedIAMPublicPermissionsServiceServer) mustEmbedUnimplementedIAMPublicPermissionsServiceServer() {
}

// UnsafeIAMPublicPermissionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMPublicPermissionsServiceServer will
// result in compilation errors.
type UnsafeIAMPublicPermissionsServiceServer interface {
	mustEmbedUnimplementedIAMPublicPermissionsServiceServer()
}

func RegisterIAMPublicPermissionsServiceServer(s grpc.ServiceRegistrar, srv IAMPublicPermissionsServiceServer) {
	s.RegisterService(&IAMPublicPermissionsService_ServiceDesc, srv)
}

func _IAMPublicPermissionsService_GetPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPublicPermissionsServiceServer).GetPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPublicPermissionsService/GetPermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPublicPermissionsServiceServer).GetPermissions(ctx, req.(*PermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAMPublicPermissionsService_ServiceDesc is the grpc.ServiceDesc for IAMPublicPermissionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMPublicPermissionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMPublicPermissionsService",
	HandlerType: (*IAMPublicPermissionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPermissions",
			Handler:    _IAMPublicPermissionsService_GetPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager/v5/iamanager.proto",
}

// IAMPublicNodesServiceClient is the client API for IAMPublicNodesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMPublicNodesServiceClient interface {
	GetAllNodeIDs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NodesID, error)
	GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error)
	SubscribeNodeChanged(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (IAMPublicNodesService_SubscribeNodeChangedClient, error)
	RegisterNode(ctx context.Context, opts ...grpc.CallOption) (IAMPublicNodesService_RegisterNodeClient, error)
}

type iAMPublicNodesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMPublicNodesServiceClient(cc grpc.ClientConnInterface) IAMPublicNodesServiceClient {
	return &iAMPublicNodesServiceClient{cc}
}

func (c *iAMPublicNodesServiceClient) GetAllNodeIDs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NodesID, error) {
	out := new(NodesID)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPublicNodesService/GetAllNodeIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMPublicNodesServiceClient) GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error) {
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPublicNodesService/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMPublicNodesServiceClient) SubscribeNodeChanged(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (IAMPublicNodesService_SubscribeNodeChangedClient, error) {
	stream, err := c.cc.NewStream(ctx, &IAMPublicNodesService_ServiceDesc.Streams[0], "/iamanager.v5.IAMPublicNodesService/SubscribeNodeChanged", opts...)
	if err != nil {
		return nil, err
	}
	x := &iAMPublicNodesServiceSubscribeNodeChangedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IAMPublicNodesService_SubscribeNodeChangedClient interface {
	Recv() (*NodeInfo, error)
	grpc.ClientStream
}

type iAMPublicNodesServiceSubscribeNodeChangedClient struct {
	grpc.ClientStream
}

func (x *iAMPublicNodesServiceSubscribeNodeChangedClient) Recv() (*NodeInfo, error) {
	m := new(NodeInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *iAMPublicNodesServiceClient) RegisterNode(ctx context.Context, opts ...grpc.CallOption) (IAMPublicNodesService_RegisterNodeClient, error) {
	stream, err := c.cc.NewStream(ctx, &IAMPublicNodesService_ServiceDesc.Streams[1], "/iamanager.v5.IAMPublicNodesService/RegisterNode", opts...)
	if err != nil {
		return nil, err
	}
	x := &iAMPublicNodesServiceRegisterNodeClient{stream}
	return x, nil
}

type IAMPublicNodesService_RegisterNodeClient interface {
	Send(*IAMOutgoingMessages) error
	Recv() (*IAMIncomingMessages, error)
	grpc.ClientStream
}

type iAMPublicNodesServiceRegisterNodeClient struct {
	grpc.ClientStream
}

func (x *iAMPublicNodesServiceRegisterNodeClient) Send(m *IAMOutgoingMessages) error {
	return x.ClientStream.SendMsg(m)
}

func (x *iAMPublicNodesServiceRegisterNodeClient) Recv() (*IAMIncomingMessages, error) {
	m := new(IAMIncomingMessages)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IAMPublicNodesServiceServer is the server API for IAMPublicNodesService service.
// All implementations must embed UnimplementedIAMPublicNodesServiceServer
// for forward compatibility
type IAMPublicNodesServiceServer interface {
	GetAllNodeIDs(context.Context, *emptypb.Empty) (*NodesID, error)
	GetNodeInfo(context.Context, *GetNodeInfoRequest) (*NodeInfo, error)
	SubscribeNodeChanged(*emptypb.Empty, IAMPublicNodesService_SubscribeNodeChangedServer) error
	RegisterNode(IAMPublicNodesService_RegisterNodeServer) error
	mustEmbedUnimplementedIAMPublicNodesServiceServer()
}

// UnimplementedIAMPublicNodesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMPublicNodesServiceServer struct {
}

func (UnimplementedIAMPublicNodesServiceServer) GetAllNodeIDs(context.Context, *emptypb.Empty) (*NodesID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllNodeIDs not implemented")
}
func (UnimplementedIAMPublicNodesServiceServer) GetNodeInfo(context.Context, *GetNodeInfoRequest) (*NodeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedIAMPublicNodesServiceServer) SubscribeNodeChanged(*emptypb.Empty, IAMPublicNodesService_SubscribeNodeChangedServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeNodeChanged not implemented")
}
func (UnimplementedIAMPublicNodesServiceServer) RegisterNode(IAMPublicNodesService_RegisterNodeServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedIAMPublicNodesServiceServer) mustEmbedUnimplementedIAMPublicNodesServiceServer() {}

// UnsafeIAMPublicNodesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMPublicNodesServiceServer will
// result in compilation errors.
type UnsafeIAMPublicNodesServiceServer interface {
	mustEmbedUnimplementedIAMPublicNodesServiceServer()
}

func RegisterIAMPublicNodesServiceServer(s grpc.ServiceRegistrar, srv IAMPublicNodesServiceServer) {
	s.RegisterService(&IAMPublicNodesService_ServiceDesc, srv)
}

func _IAMPublicNodesService_GetAllNodeIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPublicNodesServiceServer).GetAllNodeIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPublicNodesService/GetAllNodeIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPublicNodesServiceServer).GetAllNodeIDs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMPublicNodesService_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPublicNodesServiceServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPublicNodesService/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPublicNodesServiceServer).GetNodeInfo(ctx, req.(*GetNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMPublicNodesService_SubscribeNodeChanged_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IAMPublicNodesServiceServer).SubscribeNodeChanged(m, &iAMPublicNodesServiceSubscribeNodeChangedServer{stream})
}

type IAMPublicNodesService_SubscribeNodeChangedServer interface {
	Send(*NodeInfo) error
	grpc.ServerStream
}

type iAMPublicNodesServiceSubscribeNodeChangedServer struct {
	grpc.ServerStream
}

func (x *iAMPublicNodesServiceSubscribeNodeChangedServer) Send(m *NodeInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _IAMPublicNodesService_RegisterNode_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IAMPublicNodesServiceServer).RegisterNode(&iAMPublicNodesServiceRegisterNodeServer{stream})
}

type IAMPublicNodesService_RegisterNodeServer interface {
	Send(*IAMIncomingMessages) error
	Recv() (*IAMOutgoingMessages, error)
	grpc.ServerStream
}

type iAMPublicNodesServiceRegisterNodeServer struct {
	grpc.ServerStream
}

func (x *iAMPublicNodesServiceRegisterNodeServer) Send(m *IAMIncomingMessages) error {
	return x.ServerStream.SendMsg(m)
}

func (x *iAMPublicNodesServiceRegisterNodeServer) Recv() (*IAMOutgoingMessages, error) {
	m := new(IAMOutgoingMessages)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IAMPublicNodesService_ServiceDesc is the grpc.ServiceDesc for IAMPublicNodesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMPublicNodesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMPublicNodesService",
	HandlerType: (*IAMPublicNodesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllNodeIDs",
			Handler:    _IAMPublicNodesService_GetAllNodeIDs_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _IAMPublicNodesService_GetNodeInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeNodeChanged",
			Handler:       _IAMPublicNodesService_SubscribeNodeChanged_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RegisterNode",
			Handler:       _IAMPublicNodesService_RegisterNode_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "iamanager/v5/iamanager.proto",
}

// IAMNodesServiceClient is the client API for IAMNodesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMNodesServiceClient interface {
	PauseNode(ctx context.Context, in *PauseNodeRequest, opts ...grpc.CallOption) (*PauseNodeResponse, error)
	ResumeNode(ctx context.Context, in *ResumeNodeRequest, opts ...grpc.CallOption) (*ResumeNodeResponse, error)
}

type iAMNodesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMNodesServiceClient(cc grpc.ClientConnInterface) IAMNodesServiceClient {
	return &iAMNodesServiceClient{cc}
}

func (c *iAMNodesServiceClient) PauseNode(ctx context.Context, in *PauseNodeRequest, opts ...grpc.CallOption) (*PauseNodeResponse, error) {
	out := new(PauseNodeResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMNodesService/PauseNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMNodesServiceClient) ResumeNode(ctx context.Context, in *ResumeNodeRequest, opts ...grpc.CallOption) (*ResumeNodeResponse, error) {
	out := new(ResumeNodeResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMNodesService/ResumeNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAMNodesServiceServer is the server API for IAMNodesService service.
// All implementations must embed UnimplementedIAMNodesServiceServer
// for forward compatibility
type IAMNodesServiceServer interface {
	PauseNode(context.Context, *PauseNodeRequest) (*PauseNodeResponse, error)
	ResumeNode(context.Context, *ResumeNodeRequest) (*ResumeNodeResponse, error)
	mustEmbedUnimplementedIAMNodesServiceServer()
}

// UnimplementedIAMNodesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMNodesServiceServer struct {
}

func (UnimplementedIAMNodesServiceServer) PauseNode(context.Context, *PauseNodeRequest) (*PauseNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseNode not implemented")
}
func (UnimplementedIAMNodesServiceServer) ResumeNode(context.Context, *ResumeNodeRequest) (*ResumeNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeNode not implemented")
}
func (UnimplementedIAMNodesServiceServer) mustEmbedUnimplementedIAMNodesServiceServer() {}

// UnsafeIAMNodesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMNodesServiceServer will
// result in compilation errors.
type UnsafeIAMNodesServiceServer interface {
	mustEmbedUnimplementedIAMNodesServiceServer()
}

func RegisterIAMNodesServiceServer(s grpc.ServiceRegistrar, srv IAMNodesServiceServer) {
	s.RegisterService(&IAMNodesService_ServiceDesc, srv)
}

func _IAMNodesService_PauseNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMNodesServiceServer).PauseNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMNodesService/PauseNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMNodesServiceServer).PauseNode(ctx, req.(*PauseNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMNodesService_ResumeNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMNodesServiceServer).ResumeNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMNodesService/ResumeNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMNodesServiceServer).ResumeNode(ctx, req.(*ResumeNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAMNodesService_ServiceDesc is the grpc.ServiceDesc for IAMNodesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMNodesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMNodesService",
	HandlerType: (*IAMNodesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PauseNode",
			Handler:    _IAMNodesService_PauseNode_Handler,
		},
		{
			MethodName: "ResumeNode",
			Handler:    _IAMNodesService_ResumeNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager/v5/iamanager.proto",
}

// IAMProvisioningServiceClient is the client API for IAMProvisioningService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMProvisioningServiceClient interface {
	GetCertTypes(ctx context.Context, in *GetCertTypesRequest, opts ...grpc.CallOption) (*CertTypes, error)
	StartProvisioning(ctx context.Context, in *StartProvisioningRequest, opts ...grpc.CallOption) (*StartProvisioningResponse, error)
	FinishProvisioning(ctx context.Context, in *FinishProvisioningRequest, opts ...grpc.CallOption) (*FinishProvisioningResponse, error)
	Deprovision(ctx context.Context, in *DeprovisionRequest, opts ...grpc.CallOption) (*DeprovisionResponse, error)
}

type iAMProvisioningServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMProvisioningServiceClient(cc grpc.ClientConnInterface) IAMProvisioningServiceClient {
	return &iAMProvisioningServiceClient{cc}
}

func (c *iAMProvisioningServiceClient) GetCertTypes(ctx context.Context, in *GetCertTypesRequest, opts ...grpc.CallOption) (*CertTypes, error) {
	out := new(CertTypes)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMProvisioningService/GetCertTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProvisioningServiceClient) StartProvisioning(ctx context.Context, in *StartProvisioningRequest, opts ...grpc.CallOption) (*StartProvisioningResponse, error) {
	out := new(StartProvisioningResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMProvisioningService/StartProvisioning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProvisioningServiceClient) FinishProvisioning(ctx context.Context, in *FinishProvisioningRequest, opts ...grpc.CallOption) (*FinishProvisioningResponse, error) {
	out := new(FinishProvisioningResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMProvisioningService/FinishProvisioning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProvisioningServiceClient) Deprovision(ctx context.Context, in *DeprovisionRequest, opts ...grpc.CallOption) (*DeprovisionResponse, error) {
	out := new(DeprovisionResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMProvisioningService/Deprovision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAMProvisioningServiceServer is the server API for IAMProvisioningService service.
// All implementations must embed UnimplementedIAMProvisioningServiceServer
// for forward compatibility
type IAMProvisioningServiceServer interface {
	GetCertTypes(context.Context, *GetCertTypesRequest) (*CertTypes, error)
	StartProvisioning(context.Context, *StartProvisioningRequest) (*StartProvisioningResponse, error)
	FinishProvisioning(context.Context, *FinishProvisioningRequest) (*FinishProvisioningResponse, error)
	Deprovision(context.Context, *DeprovisionRequest) (*DeprovisionResponse, error)
	mustEmbedUnimplementedIAMProvisioningServiceServer()
}

// UnimplementedIAMProvisioningServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMProvisioningServiceServer struct {
}

func (UnimplementedIAMProvisioningServiceServer) GetCertTypes(context.Context, *GetCertTypesRequest) (*CertTypes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCertTypes not implemented")
}
func (UnimplementedIAMProvisioningServiceServer) StartProvisioning(context.Context, *StartProvisioningRequest) (*StartProvisioningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProvisioning not implemented")
}
func (UnimplementedIAMProvisioningServiceServer) FinishProvisioning(context.Context, *FinishProvisioningRequest) (*FinishProvisioningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishProvisioning not implemented")
}
func (UnimplementedIAMProvisioningServiceServer) Deprovision(context.Context, *DeprovisionRequest) (*DeprovisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deprovision not implemented")
}
func (UnimplementedIAMProvisioningServiceServer) mustEmbedUnimplementedIAMProvisioningServiceServer() {
}

// UnsafeIAMProvisioningServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMProvisioningServiceServer will
// result in compilation errors.
type UnsafeIAMProvisioningServiceServer interface {
	mustEmbedUnimplementedIAMProvisioningServiceServer()
}

func RegisterIAMProvisioningServiceServer(s grpc.ServiceRegistrar, srv IAMProvisioningServiceServer) {
	s.RegisterService(&IAMProvisioningService_ServiceDesc, srv)
}

func _IAMProvisioningService_GetCertTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProvisioningServiceServer).GetCertTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMProvisioningService/GetCertTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProvisioningServiceServer).GetCertTypes(ctx, req.(*GetCertTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProvisioningService_StartProvisioning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProvisioningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProvisioningServiceServer).StartProvisioning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMProvisioningService/StartProvisioning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProvisioningServiceServer).StartProvisioning(ctx, req.(*StartProvisioningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProvisioningService_FinishProvisioning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishProvisioningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProvisioningServiceServer).FinishProvisioning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMProvisioningService/FinishProvisioning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProvisioningServiceServer).FinishProvisioning(ctx, req.(*FinishProvisioningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProvisioningService_Deprovision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeprovisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProvisioningServiceServer).Deprovision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMProvisioningService/Deprovision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProvisioningServiceServer).Deprovision(ctx, req.(*DeprovisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAMProvisioningService_ServiceDesc is the grpc.ServiceDesc for IAMProvisioningService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMProvisioningService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMProvisioningService",
	HandlerType: (*IAMProvisioningServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCertTypes",
			Handler:    _IAMProvisioningService_GetCertTypes_Handler,
		},
		{
			MethodName: "StartProvisioning",
			Handler:    _IAMProvisioningService_StartProvisioning_Handler,
		},
		{
			MethodName: "FinishProvisioning",
			Handler:    _IAMProvisioningService_FinishProvisioning_Handler,
		},
		{
			MethodName: "Deprovision",
			Handler:    _IAMProvisioningService_Deprovision_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager/v5/iamanager.proto",
}

// IAMCertificateServiceClient is the client API for IAMCertificateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMCertificateServiceClient interface {
	CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error)
	ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error)
}

type iAMCertificateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMCertificateServiceClient(cc grpc.ClientConnInterface) IAMCertificateServiceClient {
	return &iAMCertificateServiceClient{cc}
}

func (c *iAMCertificateServiceClient) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error) {
	out := new(CreateKeyResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMCertificateService/CreateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMCertificateServiceClient) ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error) {
	out := new(ApplyCertResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMCertificateService/ApplyCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAMCertificateServiceServer is the server API for IAMCertificateService service.
// All implementations must embed UnimplementedIAMCertificateServiceServer
// for forward compatibility
type IAMCertificateServiceServer interface {
	CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error)
	ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error)
	mustEmbedUnimplementedIAMCertificateServiceServer()
}

// UnimplementedIAMCertificateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMCertificateServiceServer struct {
}

func (UnimplementedIAMCertificateServiceServer) CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKey not implemented")
}
func (UnimplementedIAMCertificateServiceServer) ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyCert not implemented")
}
func (UnimplementedIAMCertificateServiceServer) mustEmbedUnimplementedIAMCertificateServiceServer() {}

// UnsafeIAMCertificateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMCertificateServiceServer will
// result in compilation errors.
type UnsafeIAMCertificateServiceServer interface {
	mustEmbedUnimplementedIAMCertificateServiceServer()
}

func RegisterIAMCertificateServiceServer(s grpc.ServiceRegistrar, srv IAMCertificateServiceServer) {
	s.RegisterService(&IAMCertificateService_ServiceDesc, srv)
}

func _IAMCertificateService_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMCertificateServiceServer).CreateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMCertificateService/CreateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMCertificateServiceServer).CreateKey(ctx, req.(*CreateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMCertificateService_ApplyCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMCertificateServiceServer).ApplyCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMCertificateService/ApplyCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMCertificateServiceServer).ApplyCert(ctx, req.(*ApplyCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAMCertificateService_ServiceDesc is the grpc.ServiceDesc for IAMCertificateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMCertificateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMCertificateService",
	HandlerType: (*IAMCertificateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateKey",
			Handler:    _IAMCertificateService_CreateKey_Handler,
		},
		{
			MethodName: "ApplyCert",
			Handler:    _IAMCertificateService_ApplyCert_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager/v5/iamanager.proto",
}

// IAMPermissionsServiceClient is the client API for IAMPermissionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMPermissionsServiceClient interface {
	RegisterInstance(ctx context.Context, in *RegisterInstanceRequest, opts ...grpc.CallOption) (*RegisterInstanceResponse, error)
	UnregisterInstance(ctx context.Context, in *UnregisterInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type iAMPermissionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMPermissionsServiceClient(cc grpc.ClientConnInterface) IAMPermissionsServiceClient {
	return &iAMPermissionsServiceClient{cc}
}

func (c *iAMPermissionsServiceClient) RegisterInstance(ctx context.Context, in *RegisterInstanceRequest, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPermissionsService/RegisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMPermissionsServiceClient) UnregisterInstance(ctx context.Context, in *UnregisterInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v5.IAMPermissionsService/UnregisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAMPermissionsServiceServer is the server API for IAMPermissionsService service.
// All implementations must embed UnimplementedIAMPermissionsServiceServer
// for forward compatibility
type IAMPermissionsServiceServer interface {
	RegisterInstance(context.Context, *RegisterInstanceRequest) (*RegisterInstanceResponse, error)
	UnregisterInstance(context.Context, *UnregisterInstanceRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedIAMPermissionsServiceServer()
}

// UnimplementedIAMPermissionsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMPermissionsServiceServer struct {
}

func (UnimplementedIAMPermissionsServiceServer) RegisterInstance(context.Context, *RegisterInstanceRequest) (*RegisterInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterInstance not implemented")
}
func (UnimplementedIAMPermissionsServiceServer) UnregisterInstance(context.Context, *UnregisterInstanceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterInstance not implemented")
}
func (UnimplementedIAMPermissionsServiceServer) mustEmbedUnimplementedIAMPermissionsServiceServer() {}

// UnsafeIAMPermissionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMPermissionsServiceServer will
// result in compilation errors.
type UnsafeIAMPermissionsServiceServer interface {
	mustEmbedUnimplementedIAMPermissionsServiceServer()
}

func RegisterIAMPermissionsServiceServer(s grpc.ServiceRegistrar, srv IAMPermissionsServiceServer) {
	s.RegisterService(&IAMPermissionsService_ServiceDesc, srv)
}

func _IAMPermissionsService_RegisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPermissionsServiceServer).RegisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPermissionsService/RegisterInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPermissionsServiceServer).RegisterInstance(ctx, req.(*RegisterInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMPermissionsService_UnregisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMPermissionsServiceServer).UnregisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v5.IAMPermissionsService/UnregisterInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMPermissionsServiceServer).UnregisterInstance(ctx, req.(*UnregisterInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAMPermissionsService_ServiceDesc is the grpc.ServiceDesc for IAMPermissionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMPermissionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v5.IAMPermissionsService",
	HandlerType: (*IAMPermissionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterInstance",
			Handler:    _IAMPermissionsService_RegisterInstance_Handler,
		},
		{
			MethodName: "UnregisterInstance",
			Handler:    _IAMPermissionsService_UnregisterInstance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager/v5/iamanager.proto",
}
